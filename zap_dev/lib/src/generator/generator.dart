import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/syntactic_entity.dart';
import 'package:analyzer/dart/ast/visitor.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:analyzer/dart/element/type_visitor.dart';
import 'package:build/build.dart';
import 'package:collection/collection.dart';

import '../resolver/component.dart';
import '../resolver/dart.dart';
import '../resolver/flow.dart';
import '../resolver/resolver.dart';
import '../resolver/reactive_dom.dart';
import '../resolver/preparation.dart';
import '../utils/dart.dart';

import 'imports.dart';
import 'options.dart';
import 'ssr/node_to_text.dart';
import 'tree.dart';

const _prefix = r'_$';
const _parentField = '${_prefix}parent';

class Generator {
  final GenerationScope libraryScope = GenerationScope();
  late final ImportsTracker imports;

  final GenerationOptions options;

  final PrepareResult prepareResult;
  final ResolvedComponent component;

  final Map<BaseZapVariable, String> _varNames = {};
  final Map<ReactiveNode, String> _nodeNames = {};
  final Map<FunctionElement, String> _functionNames = {};
  final Map<Object, String> _miscNames = {};

  String get zapPrefix => imports.zapImport;
  String get htmlPrefix => imports.dartHtmlImport;

  Generator(this.component, this.prepareResult, this.options, AssetId output) {
    imports = ImportsTracker(libraryScope.inner(), output);
  }

  String _nameForVar(BaseZapVariable variable) {
    return _varNames.putIfAbsent(variable, () {
      return '${_prefix}v${_varNames.length}';
    });
  }

  String _nameForNode(ReactiveNode node) {
    return _nodeNames.putIfAbsent(node, () {
      return '${_prefix}n${_nodeNames.length}';
    });
  }

  String _nameForFunction(FunctionElement fun) {
    return _functionNames.putIfAbsent(fun, () => '${_prefix}fun_${fun.name}');
  }

  String _nameForMisc(Object key) {
    return _miscNames.putIfAbsent(
        key, () => '_${_prefix}t${_miscNames.length}');
  }

  void write() {
    imports.imports.writeln('// Generated by zap_dev, do not edit!');
    _writeComponent(component.component);

    // Write top-level members declared outside of the component (in a
    // `<script context="module">` scope).
    for (final declaration in component.declarationsFromModuleScope) {
      libraryScope.leaf().write(_DartSourceRewriter.patchDartReferences(
            dartCode: declaration,
            generator: this,
            patchSelf: false, // Not in a component, can't use `self`.
          ));
    }

    imports.ensureImportsAreWritten();
  }

  void _writeComponent(ComponentOrSubcomponent component) {
    _ComponentOrSubcomponentWriter writer;
    final scope = libraryScope.inner(ScopeLevel.$class);
    final opt = this.component.optimization.forComponent(component);

    if (component is Component) {
      writer = _ComponentWriter(
          component, this.component.componentName, this, scope);
    } else {
      // Instead of writing a full class, we can write this fragment as a static
      // node.
      if (opt.isCompileTimeConstant) {
        _writeConstantComponent(component as ResolvedSubComponent);
        return;
      }

      writer =
          _SubComponentWriter(component as ResolvedSubComponent, this, scope);
    }

    writer.write();

    component.children.forEach(_writeComponent);
  }

  void _writeConstantComponent(ResolvedSubComponent component) {
    final name = _nameForMisc(component);
    final writer = NodeWriter();
    component.fragment.rootNodes.forEach(writer.writeNode);

    libraryScope.leaf().write('final $name = $zapPrefix.HtmlTag'
        '(${dartStringLiteral(writer.buffer.toString())});');
  }
}

abstract class _ComponentOrSubcomponentWriter {
  final Generator generator;
  final GenerationScope classScope;
  final StringBuffer buffer;

  ComponentOrSubcomponent get component;

  _ComponentOrSubcomponentWriter(this.generator, this.classScope)
      : buffer = classScope.leaf();

  bool _rendersSubcomponents(ReactiveNode node) =>
      node is SubComponent || node is ReactiveBlock || node is MountSlot;

  bool _isZapFragment(ReactiveNode node) =>
      _rendersSubcomponents(node) || node is ReactiveRawHtml;

  bool _passDownUpdates(ReactiveNode node) =>
      _isZapFragment(node) && node is! SubComponent;

  bool _isInitializedLater(ReactiveNode node) => _rendersSubcomponents(node);

  void write();

  String get componentThis {
    if (component is Component) {
      // Root component
      return 'this';
    } else {
      return _DartSourceRewriter(generator, component.scope, 0, '', true)
          ._prefixFor(generator.component.component.scope, trailingDot: false);
    }
  }

  String get atOverride => '@${prefixIdentifier('override')}';

  String prefixIdentifier(String identifier, [String from = 'dart:core']) {
    final uri = Uri.parse(from);
    return '${generator.imports.importForUri(uri)}.$identifier';
  }

  String dartTypeToString(DartType type) {
    final buffer = StringBuffer();

    type.accept(_DartTypeWriter(generator, buffer));
    return buffer.toString();
  }

  String? dartTypeName(ReactiveNode node) {
    final htmlPrefix = generator.imports.dartHtmlImport;
    final zapPrefix = generator.imports.zapImport;

    if (node is ReactiveElement) {
      final known = node.knownElement;

      return known != null
          ? '$htmlPrefix.${known.className}'
          : '$htmlPrefix.Element';
    } else if (node is ReactiveText || node is ConstantText) {
      return '$htmlPrefix.Text';
    } else if (node is ReactiveRawHtml) {
      return '$zapPrefix.HtmlTag';
    } else if (node is SubComponent) {
      final prefix = generator.imports.importForIntermediateLibrary(
          node.component.temporaryApiClass.library);
      return '$prefix.${node.component.temporaryApiClass.name}';
    } else if (node is DynamicSubComponent) {
      return '$zapPrefix.DynamicComponent';
    } else if (node is ReactiveIf) {
      return '$zapPrefix.IfBlock';
    } else if (node is ReactiveFor) {
      final innerType = dartTypeToString(node.elementType);
      return '$zapPrefix.ForBlock<$innerType>';
    } else if (node is ReactiveAsyncBlock) {
      final innerType = dartTypeToString(node.type);

      return node.isStream
          ? '$zapPrefix.StreamBlock<$innerType>'
          : '$zapPrefix.FutureBlock<$innerType>';
    } else if (node is MountSlot) {
      return '$zapPrefix.Slot';
    } else {
      return null;
    }
  }

  String _slotVariable(String? slot) {
    return '\$slot_${slot ?? ''}';
  }

  bool _componentIsOptimizedAway(ComponentOrSubcomponent component) {
    final opt = generator.component.optimization.forComponent(component);
    return opt.isCompileTimeConstant;
  }

  String _createSubFragment(
      ComponentOrSubcomponent subComponent, String constructorArguments) {
    final name = generator._nameForMisc(subComponent);

    if (_componentIsOptimizedAway(subComponent)) {
      // We'll write a top-level field for this constant fragment.
      return name;
    } else {
      return '$name($constructorArguments)';
    }
  }

  String _statementsToChangeVariable(
      BaseZapVariable variable, String expression) {
    final prefix = _DartSourceRewriter(generator, component.scope, 0, '', true)
        ._prefixFor(variable.scope);
    final variableName = generator._nameForVar(variable);

    final result = StringBuffer();
    if (variable.needsUpdateTracking) {
      result.writeln('$prefix\$invalidate(${variable.updateBitmask});');
    }

    result.writeln('$prefix$variableName = $expression;');
    return result.toString();
  }

  void writeNodesAndBlockHelpers() {
    // Write instance fields storing DOM nodes or zap block helpers
    for (final node in component.fragment.allNodes) {
      final name = generator._nameForNode(node);
      final isInitializedLater = _isInitializedLater(node);

      if (isInitializedLater) {
        buffer.write('late ');
      }

      buffer
        ..write('final ')
        ..write(dartTypeName(node))
        ..write(' ')
        ..write(name);

      if (!isInitializedLater) {
        buffer.write(' = ');
        createNode(node);
      }

      buffer.writeln(';');

      if (node is ReactiveIf) {
        // Write a function used to evaluate the condition for an if block
        final name = generator._nameForMisc(node);
        buffer.writeln('${prefixIdentifier('int')} $name() {');
        for (var i = 0; i < node.conditions.length; i++) {
          if (i != 0) {
            buffer.write('else ');
          }
          buffer.write('if(');
          writeDartWithPatchedReferences(node.conditions[i]);
          buffer
            ..writeln(') {')
            ..writeln('  return $i;')
            ..writeln('}');
        }
        buffer.writeln('else { return ${node.conditions.length}; }}');
      }
    }
  }

  void writeCreateMethod() {
    final name = component is Component ? 'createInternal' : 'create';
    final prefix = generator.htmlPrefix;

    buffer
      ..writeln(atOverride)
      ..writeln('void $name($prefix.Element target, [$prefix.Node? anchor]) {');

    // Create subcomponents. They require evaluating Dart expressions, so we
    // can't do this earlier.
    for (final node in component.fragment.allNodes) {
      if (_isInitializedLater(node)) {
        buffer
          ..write(generator._nameForNode(node))
          ..write(' = ');
        createNode(node);
        buffer.writeln(';');
      }

      // Implement `bind:this` binders by assigning nodes to their target
      // variables now.
      if (node is ReactiveElement) {
        for (final binder in node.binders) {
          final target = binder.target;
          final prefix =
              _DartSourceRewriter(generator, component.scope, 0, '', true)
                  ._prefixFor(target.scope);
          final variableName = generator._nameForVar(target);
          final nodeName = generator._nameForNode(node);

          if (binder is BindThis) {
            buffer.write(_statementsToChangeVariable(target, nodeName));
          } else if (binder is BindProperty) {
            final callback = '''
                (value) {
                  if (value != $prefix$variableName) {
                    ${_statementsToChangeVariable(target, 'value')}
                  }
                }
            ''';

            switch (binder.specialMode) {
              case SpecialBindingMode.inputValue:
                final import = generator.imports.dartHtmlImport;
                buffer.write('$import.GlobalEventHandlers.inputEvent'
                    '.forElement($nodeName)'
                    '.map((e) => $nodeName.value)'
                    '.transform(lifecycle())'
                    '.listen($callback);');
                break;
              case null:
                buffer
                  ..write(nodeName)
                  ..write('.watchAttribute(')
                  ..write(dartStringLiteral(binder.attribute))
                  ..write(')')
                  ..write('.transform(lifecycle())')
                  ..writeln('.listen($callback);');
                break;
            }
          }
        }
      }
    }

    // In the create method, we set the initial value of Dart expressions and
    // register event handlers.
    for (final flow in component.flows) {
      if (flow.isOneOffAction) {
        writeFlowAction(flow, isInCreate: true);
      }
    }

    void writeAdd(Iterable<ReactiveNode> nodes, String target, String? anchor) {
      for (final node in nodes) {
        final name = generator._nameForNode(node);

        if (_isZapFragment(node)) {
          buffer
            ..write(name)
            ..writeln('.create($target, $anchor);');
          continue;
        } else if (anchor == null) {
          // Write an append call
          buffer.writeln('$target.append($name);');
        } else {
          // Use insertBefore then
          buffer.writeln('$target.insertBefore($name, $anchor);');
        }

        // Mount child nodes as well
        writeAdd(node.children, name, null);
      }
    }

    /// Also add nodes into the document now.
    writeAdd(component.fragment.rootNodes, 'target', 'anchor');
    buffer.writeln('}');
  }

  void writeRemoveMethod() {
    final name = component is Component ? 'remove' : 'destroy';

    buffer
      ..writeln(atOverride)
      ..writeln('void $name() {');

    for (final rootNode in component.fragment.rootNodes) {
      buffer.write(generator._nameForNode(rootNode));

      if (_isZapFragment(rootNode)) {
        // use .destroy() to unmount zap components
        buffer.write('.destroy();');
      } else {
        // and .remove() to unmount `dart:html` elements.
        buffer.write('.remove();');
      }
    }

    // We can unmount the root nodes to remove this component from the DOM tree.
    // However, we should still explicitly destroy() child components so that
    // they can clean up resources.
    for (final node
        in component.fragment.rootNodes.expand((node) => node.allDescendants)) {
      if (_rendersSubcomponents(node)) {
        buffer.write(generator._nameForNode(node));

        buffer.write('.destroy();');
      }
    }

    buffer.writeln('}');
  }

  void writeUpdateMethod() {
    buffer
      ..writeln(atOverride)
      ..writeln('void update(${prefixIdentifier('int')} delta) {');

    for (final flow in component.flows) {
      if (!flow.isOneOffAction) {
        buffer
          ..write('if (delta & ')
          ..write(flow.bitmask)
          ..writeln(' != 0) {');
        writeFlowAction(flow);
        buffer.writeln('}');
      }
    }

    // Some nodes manage subcomponents and need to be updated as well
    for (final node in component.fragment.allNodes.where(_passDownUpdates)) {
      final name = generator._nameForNode(node);
      buffer.writeln('$name.update(delta);');
    }

    buffer.writeln('}');
  }

  void writeFlowAction(Flow flow, {bool isInCreate = false}) {
    final action = flow.action;

    if (action is SideEffect) {
      writeDartWithPatchedReferences(action.statement);
    } else if (action is ChangeText) {
      writeSetText(action.text);
    } else if (action is RegisterEventHandler) {
      final handler = action.handler;
      if (flow.isOneOffAction) {
        // Just register the event handler, it won't be changed later!
        registerEventHandler(handler);
      } else {
        if (isInCreate) {
          // We need to store the result of listening in a stream subscription
          // so that the event handler can be changed later.
          buffer
            ..write(generator._nameForMisc(handler))
            ..write(' = ');
          registerEventHandler(handler);
        } else {
          // Just change the onData callback of the stream subscription now
          buffer
            ..write(generator._nameForMisc(handler))
            ..write('onData(');
          callbackForEventHandler(handler);
          buffer.writeln(');');
        }
      }
    } else if (action is ApplyAttribute) {
      final attribute = action.element.attributes[action.name]!;
      final nodeName = generator._nameForNode(action.element);

      switch (attribute.mode) {
        case AttributeMode.setValue:
          buffer.write(nodeName);

          if (action.name == 'class' &&
              generator.component.cssClassName != null) {
            // Make sure the scoped css class is still included when setting the
            // class attribute
            buffer
              ..write('.setClassAttribute(')
              ..write(dartStringLiteral(generator.component.cssClassName!))
              ..write(', ');
            writeDartWithPatchedReferences(attribute.backingExpression);
            buffer.writeln('.toString());');
          } else {
            // Just emit node.attributes[key] = value.toString()
            buffer
              ..write(".attributes['")
              ..write(action.name)
              ..write("'] = ");
            writeDartWithPatchedReferences(attribute.backingExpression);
            buffer.writeln('.toString();');
          }

          break;
        case AttributeMode.addIfTrue:
          // Emit node.applyBooleanAttribute(key, value)
          buffer
            ..write(nodeName)
            ..write(".applyBooleanAttribute('")
            ..write(action.name)
            ..write("', ");
          writeDartWithPatchedReferences(attribute.backingExpression);
          buffer.writeln(');');
          break;
        case AttributeMode.setIfNotNullClearOtherwise:
          buffer
            ..write(nodeName)
            ..write(".applyAttributeIfNotNull('")
            ..write(action.name)
            ..write("', ");
          writeDartWithPatchedReferences(attribute.backingExpression);
          buffer.writeln(');');
          break;
      }
    } else if (action is ChangePropertyOfSubcomponent) {
      final target = generator._nameForNode(action.subcomponent);
      buffer.write('$target.${action.property} = ');
      writeDartWithPatchedReferences(
          action.subcomponent.expressions[action.property]!);
      buffer.writeln(';');
    } else if (action is UpdateBlockExpression) {
      final block = action.block;
      final nodeName = generator._nameForNode(action.block);

      if (block is ReactiveIf) {
        final nameOfBranchFunction = generator._nameForMisc(block);

        buffer
          ..write(nodeName)
          ..write('.reEvaluate($nameOfBranchFunction());');
      } else if (block is ReactiveAsyncBlock) {
        final nodeName = generator._nameForNode(block);

        final setter = block.isStream ? 'stream' : 'future';
        final prefix = generator.zapPrefix;
        final wrapper =
            block.isStream ? '$prefix.\$safeStream' : '$prefix.\$safeFuture';
        final type = dartTypeToString(block.type);

        buffer.write('$nodeName.$setter = $wrapper<$type>(() => ');
        writeDartWithPatchedReferences(block.expression);
        buffer.write(');');
      } else if (block is ReactiveFor) {
        final nodeName = generator._nameForNode(block);

        buffer.write('$nodeName.data = ');
        writeDartWithPatchedReferences(block.expression);
        buffer.write(';');
      } else if (block is ReactiveKeyBlock) {
        buffer.write('$nodeName.value = ');
        writeDartWithPatchedReferences(block.expression);
        buffer.write(';');
      } else if (block is ReactiveRawHtml) {
        buffer.write('$nodeName.rawHtml = ');
        if (block.needsToString) {
          buffer.write('(');
          writeDartWithPatchedReferences(block.expression);
          buffer.write(').toString()');
        } else {
          writeDartWithPatchedReferences(block.expression);
        }
        buffer.write(';');
      } else if (block is DynamicSubComponent) {
        buffer.write('$nodeName.component = ');
        writeDartWithPatchedReferences(block.expression);
        buffer.write(';');
      } else {
        throw ArgumentError('Unknown target for $action: ${action.block}');
      }
    }
  }

  void registerEventHandler(EventHandler handler) {
    final knownEvent = handler.knownType;
    final parent = handler.parent;
    final node = generator._nameForNode(parent);

    void writeStreamToListenTo() {
      // Write the `Stream` expression for this event handler.
      if (parent is SubComponent) {
        final type = dartTypeToString(handler.dartEventType);
        buffer.write('$node.componentEvents<$type>'
            '(${dartStringLiteral(handler.event)})');
      } else {
        buffer.write('${generator.imports.dartHtmlImport}.');

        if (knownEvent != null) {
          buffer.write(knownEvent.providerExpression);
        } else {
          buffer.write("const EventStreamProvider('${handler.event}')");
        }

        buffer.write('.forElement($node');
        if (handler.isCapturing) {
          buffer.write(', useCapture = true');
        }
        buffer.write(')');
      }

      if (handler.modifier.isNotEmpty) {
        // Transform the event stream to account for the modifiers.
        buffer.write('.withModifiers(');

        for (final modifier in handler.modifier) {
          switch (modifier) {
            case EventModifier.preventDefault:
              buffer.write('preventDefault: true,');
              break;
            case EventModifier.stopPropagation:
              buffer.write('stopPropagation: true,');
              break;
            case EventModifier.passive:
              buffer.write('passive: true,');
              break;
            case EventModifier.nonpassive:
              buffer.write('passive: false,');
              break;
            case EventModifier.once:
              buffer.write('once: true,');
              break;
            case EventModifier.self:
              buffer.write('onlySelf: true,');
              break;
            case EventModifier.trusted:
              buffer.write('onlyTrusted: true,');
              break;
            case EventModifier.capture:
            // Handled by useCapture: true above
          }
        }

        buffer.write(')');
      }
    }

    if (handler.isForwarding) {
      buffer.write('$componentThis.forwardEvents(');
      writeStreamToListenTo();
      buffer.write(');');
    } else {
      writeStreamToListenTo();
      buffer.write('.listen(');
      callbackForEventHandler(handler);
      buffer.write(');');
    }
  }

  void callbackForEventHandler(EventHandler handler) {
    final listener = handler.listener!;

    if (handler.isNoArgsListener) {
      // The handler does not take any arguments, so we have to wrap it in a
      // function that does.
      buffer.write('(_) {(');
      writeDartWithPatchedReferences(listener);
      buffer.write(')();}');
    } else {
      // A tear-off will do
      writeDartWithPatchedReferences(listener);
    }
  }

  void createNode(ReactiveNode node) {
    final htmlPrefix = generator.htmlPrefix;
    final zapPrefix = generator.zapPrefix;

    if (node is ReactiveElement) {
      final known = node.knownElement;

      if (known != null) {
        final type = '$htmlPrefix.${known.className}';

        if (known.instantiable) {
          // Use a direct constructor provided by the Dart SDK
          buffer.write(type);
          if (known.constructorName.isNotEmpty) {
            buffer.write('.${known.constructorName}');
          }

          buffer.write('()');
        } else {
          // Use the newElement helper method from zap
          buffer.write(
              '$zapPrefix.newElement<$type>(${dartStringLiteral(node.tagName)})');
        }
      } else {
        buffer.write("$htmlPrefix.Element.tag('${node.tagName}')");
      }

      final className = generator.component.cssClassName;
      if (className != null) {
        buffer.write("..addComponentClass('$className')");
      }
    } else if (node is ReactiveText) {
      buffer.write("$htmlPrefix.Text('')");
    } else if (node is ConstantText) {
      buffer.write("$htmlPrefix.Text(${dartStringLiteral(node.text)})");
    } else if (node is ReactiveRawHtml) {
      buffer.write('$zapPrefix.HtmlTag()');
    } else if (node is SubComponent) {
      final typeName = dartTypeName(node);

      void instantiateComponent() {
        buffer.write('$typeName(');

        // Write properties passed down to the component.
        for (final property in node.component.parameters) {
          final name = property.key;
          final actualValue = node.expressions[name];

          if (actualValue == null) {
            buffer.write('null');
          } else {
            // Wrap values in a ZapBox to distinguish between set and absent
            // parameters.
            buffer.write('$zapPrefix.ZapValue(');
            writeDartWithPatchedReferences(actualValue);
            buffer.write(')');
          }

          buffer.write(',');
        }

        // Also write slots passed down.
        for (final slot in node.component.slotNames) {
          final child = slot == null ? node.defaultSlot : node.slots[slot];

          if (child == null) {
            buffer.write('null');
          } else {
            final classOfFragment =
                generator._nameForMisc(child.owningComponent!);
            buffer.write('() => $classOfFragment(this)');
          }

          buffer.write(',');
        }

        buffer.writeln(')');
      }

      final component = this.component;
      if (component is ResolvedSubComponent && component.isMountedInSlot) {
        // The slot owner will take care of assigning the right parent context.
        instantiateComponent();
      } else {
        buffer
          ..write(componentThis)
          ..write('.\$createChildComponent<$typeName>(() => ');
        instantiateComponent();
        buffer.write(')');
      }
    } else if (node is DynamicSubComponent) {
      buffer.write('$zapPrefix.DynamicComponent(');
      writeDartWithPatchedReferences(node.expression);
      buffer.write(')');
    } else if (node is ReactiveIf) {
      buffer
        ..writeln('$zapPrefix.IfBlock((caseNum) {')
        ..writeln('switch (caseNum) {');

      for (var i = 0; i < node.whens.length; i++) {
        final component = node.whens[i].owningComponent!;

        buffer.writeln(
            'case $i: return ${_createSubFragment(component, 'this')};');
      }

      final defaultCase = node.otherwise?.owningComponent;
      if (defaultCase != null) {
        buffer.writeln(
            'default: return ${_createSubFragment(defaultCase, 'this')};');
      } else {
        buffer.writeln('default: return null;');
      }

      buffer.writeln('}})');
    } else if (node is ReactiveAsyncBlock) {
      final childComponent = node.fragment.owningComponent!;
      final name = node.fragment.resolvedScope
          .findForSubcomponent(SubcomponentVariableKind.asyncSnapshot)!
          .element
          .name;

      final create = _createSubFragment(childComponent, 'this');
      // If the component was optimized to a static html string, we don't have
      // to apply any updates.
      final update = _componentIsOptimizedAway(childComponent)
          ? '(_, __) {}'
          : '(fragment, snapshot) => '
              '(fragment as ${generator._nameForMisc(childComponent)})'
              '.$name = snapshot';

      final className = node.isStream ? 'StreamBlock' : 'FutureBlock';
      buffer.writeln('$zapPrefix.$className($create, $update)');
    } else if (node is ReactiveFor) {
      final subComponent = node.fragment.owningComponent!;

      final elementVariable = node.fragment.resolvedScope
          .findForSubcomponent(SubcomponentVariableKind.forBlockElement)!;
      final indexVariable = node.fragment.resolvedScope
          .findForSubcomponent(SubcomponentVariableKind.forBlockIndex);

      buffer.writeln('$zapPrefix.ForBlock(');

      // Write the function creating child nodes
      buffer.write('(element, index) => ');
      if (indexVariable != null) {
        buffer.write(_createSubFragment(subComponent, 'this, element, index'));
      } else {
        buffer.write(_createSubFragment(subComponent, 'this, element'));
      }

      // Write the function updating child nodes
      if (_componentIsOptimizedAway(subComponent)) {
        buffer.write(', (_, __, ___) {}');
      } else {
        final childClass = generator._nameForMisc(subComponent);

        buffer
          ..write(', (fragment, element, index) => ')
          ..write('(fragment as $childClass)')
          ..write('..${elementVariable.element.name} = element');

        if (indexVariable != null) {
          buffer.write('..${indexVariable.element.name} = index');
        }
      }

      buffer.write(')');
    } else if (node is MountSlot) {
      final createFallback = _createSubFragment(
          node.defaultContent.owningComponent!, componentThis);

      final providedSlot = '$componentThis.${_slotVariable(node.slotName)}';
      final fallback = '() => $createFallback';

      buffer
          .write('$zapPrefix.Slot($providedSlot ?? $fallback, $componentThis)');
    } else {
      throw ArgumentError('Unknown node type: $node');
    }
  }

  void writePropertyAccessors() {
    final variablesThatNeedChanges =
        component.scope.declaredVariables.where((variable) {
      if (variable is DartCodeVariable) {
        return variable.isProperty;
      } else if (variable is SubcomponentVariable) {
        switch (variable.kind) {
          case SubcomponentVariableKind.asyncSnapshot:
          case SubcomponentVariableKind.forBlockElement:
          case SubcomponentVariableKind.forBlockIndex:
            return true;
        }
      } else {
        return false;
      }
    });

    for (final variable in variablesThatNeedChanges) {
      final element = variable.element;
      final type = dartTypeToString(variable.type);
      final name = generator._nameForVar(variable);

      // int get foo => $$_v0;
      buffer
        ..write(type)
        ..write(' get ')
        ..write(element.name)
        ..write(' => ')
        ..write(name)
        ..writeln(';');

      if (variable.isMutable) {
        // set foo (int value) {
        //   if (value != $$_v0) {
        //     $$_v0 = value;
        //     $invalidate(bitmask);
        //   }
        // }
        buffer
          ..writeln('set ${element.name} ($type value) {')
          ..writeln('  if (value != $name) {')
          ..writeln('    $name = value;');
        if (variable.needsUpdateTracking) {
          final update =
              _DartSourceRewriter(generator, component.scope, 0, '', true)
                  .invalidateExpression(variable.updateBitmask.toString());
          buffer.writeln('    $update');
        }
        buffer
          ..writeln('  }')
          ..writeln('}');
      }
    }
  }

  void writeSetText(ReactiveText target) {
    buffer
      ..write(generator._nameForNode(target))
      ..write('.zapText = ');

    final expression = target.expression;
    if (target.needsToString) {
      // Call .toString() on the result
      buffer.write('(');
      writeDartWithPatchedReferences(expression);
      buffer.write(').toString()');
    } else {
      // No .toString() call necessary, just embed the expression directly.
      writeDartWithPatchedReferences(expression);
    }

    buffer.writeln(';');
  }

  void writeDartWithPatchedReferences(AstNode dartCode,
      {bool patchSelf = true}) {
    buffer.write(
      _DartSourceRewriter.patchDartReferences(
        dartCode: dartCode,
        patchSelf: patchSelf,
        generator: generator,
        component: component,
      ),
    );
  }
}

class _ComponentWriter extends _ComponentOrSubcomponentWriter {
  @override
  final Component component;
  final String name;

  _ComponentWriter(this.component, this.name, Generator generator,
      GenerationScope classScope)
      : super(generator, classScope);

  @override
  void write() {
    final prefix = generator.imports.zapImport;
    buffer.writeln('class $name extends $prefix.ZapComponent {');

    // Write variables:
    for (final variable
        in component.scope.declaredVariables.whereType<DartCodeVariable>()) {
      final name = generator._nameForVar(variable);
      // Variables need to be late because we only set them in the constructor's
      // body.
      buffer.write('late ');

      if (!variable.isMutable) buffer.write('final ');

      buffer
        ..write(dartTypeToString(variable.element.type))
        ..write(' ')
        ..write(name)
        ..write(';')
        ..writeln(' // ${variable.element.name}');
    }

    // Slots are also passed down as variables
    for (final slot in component.usedSlots) {
      final name = _slotVariable(slot);
      buffer.writeln('final $prefix.Fragment Function()? $name;');
    }

    // And DOM nodes
    writeNodesAndBlockHelpers();

    // Mutable stream subscriptions are stored as instance variables too
    for (final flow in component.flows) {
      final action = flow.action;
      if (!flow.isOneOffAction && action is RegisterEventHandler) {
        final htmlPrefix = generator.imports.dartHtmlImport;
        final type = dartTypeToString(action.handler.dartEventType);

        buffer
          ..write('late ')
          ..write('StreamSubscription<$htmlPrefix.')
          ..write(type)
          ..write('> ')
          ..write(generator._nameForMisc(action.handler))
          ..writeln(';');
      }
    }

    writeConstructor();

    writeCreateMethod();
    writeRemoveMethod();
    writeUpdateMethod();
    writePropertyAccessors();

    // Write functions that were declared in the component
    for (final statement in component.instanceFunctions) {
      writeDartWithPatchedReferences(statement.functionDeclaration);
    }

    buffer.writeln('}');
  }

  void writeConstructor() {
    final zapPrefix = generator.imports.zapImport;

    buffer.write('$name(');
    final dartVariables =
        component.scope.declaredVariables.whereType<DartCodeVariable>();

    final properties = dartVariables.where((e) => e.isProperty);

    for (final variable in properties) {
      // Wrap properties in a ZapValue so that we can fallback to the default
      // value otherwise. We can't use optional parameters as the default
      // doesn't have to be a constant.
      // todo: Don't do that if the parameter is non-nullable
      final element = variable.element;
      final innerType = dartTypeToString(element.type);
      final type = '$zapPrefix.ZapValue<$innerType>?';
      buffer
        ..write(type)
        ..write(r' $')
        ..write(element.name)
        ..write(',');
    }

    // Also write slots
    for (final slot in component.usedSlots) {
      buffer.write('this.${_slotVariable(slot)},');
    }

    buffer.writeln(') {');

    buffer.writeln('final self = $zapPrefix.PendingComponent();');

    for (final initializer in component.componentInitializers) {
      if (initializer is InitializeStatement) {
        final initializedVariable = initializer.initializedVariable;
        final statement = initializer.dartStatement;

        // Rewrite variable declarations to instead initialize the field on
        // the component instance.
        if (statement is VariableDeclarationStatement &&
            initializedVariable != null) {
          if (initializedVariable.watching != null) {
            final varInit = statement.variables.variables.first.initializer!
                as MethodInvocation;

            final watchableExpr = varInit.argumentList.arguments.single;
            // This variable is watching another expression. Store that
            // expression in a temporary variable, assign and set up watcher.
            final variableName = generator._nameForMisc(initializer);
            buffer.write('final $variableName = ');
            writeDartWithPatchedReferences(watchableExpr, patchSelf: false);
            buffer.writeln(';');

            // Assign
            buffer
              ..write(generator._nameForVar(initializedVariable))
              ..write(' = $variableName.value;');

            // Setup watcher
            buffer
              ..writeln('$variableName.transform(lifecycle()).listen((value) {')
              ..writeln(
                  _statementsToChangeVariable(initializedVariable, 'value'))
              ..writeln('});');
          } else {
            for (final variable in statement.variables.variables) {
              final initializer = variable.initializer;
              final zapTarget = component.scope.declaredVariables
                  .firstWhereOrNull(
                      (zap) => zap.element == variable.declaredElement);
              if (zapTarget != null) {
                final field = generator._nameForVar(zapTarget);

                if (initializer != null) {
                  // Convert to assignment
                  buffer.write('$field = ');
                  writeDartWithPatchedReferences(initializer, patchSelf: false);
                  buffer.writeln(';');
                } else if (generator.component.typeSystem
                    .isNullable(zapTarget.type)) {
                  // Implicitly initialized to null at the declaration
                  buffer.writeln('$field = null;');
                }
              }
            }
          }
        } else {
          writeDartWithPatchedReferences(initializer.dartStatement,
              patchSelf: false);
        }
      } else if (initializer is InitializeProperty) {
        // We have the property as $property, wrapped in a nullable
        // ZapValue.
        // So write `<type> variable = $variable != null ? $variable.value : <d>`
        final variable = initializer.variable;
        final element = variable.element;

        buffer
          ..write(generator._nameForVar(variable))
          ..write(r' = $')
          ..write(element.name)
          ..write(' != null ? ')
          ..write(r'$')
          ..write(element.name)
          ..write('.value : (');

        final declaration = variable.declaration;
        final defaultExpr =
            declaration is VariableDeclaration ? declaration.initializer : null;
        final isNullable =
            generator.component.typeSystem.isNullable(variable.type);

        if (defaultExpr != null) {
          writeDartWithPatchedReferences(defaultExpr, patchSelf: false);
        } else if (isNullable) {
          buffer.write('null');
        } else {
          // No initializer and no value set -> error
          final argumentError = prefixIdentifier('ArgumentError');
          buffer.write(
              'throw $argumentError(${dartStringLiteral('Parameter ${element.name} is required!')})');
        }

        buffer.write(');');
      }
    }

    buffer.writeln('takeOverPending(self);}');
  }
}

class _SubComponentWriter extends _ComponentOrSubcomponentWriter {
  @override
  final ResolvedSubComponent component;

  _SubComponentWriter(
      this.component, Generator generator, GenerationScope classScope)
      : super(generator, classScope);

  @override
  void write() {
    final zapPrefix = generator.imports.zapImport;

    final name = generator._nameForMisc(component);
    buffer.writeln('class $name extends $zapPrefix.Fragment {');

    final parent = component.parent!;
    final parentType = parent is Component
        ? generator.component.componentName
        : generator._nameForMisc(parent);

    final needsInitialization = <String>[];

    // Inside subfragments, variables are instiated by the parent component
    // before calling create()
    for (final variable
        in component.scope.declaredVariables.cast<SubcomponentVariable>()) {
      final type = dartTypeToString(variable.type);
      final name = generator._nameForVar(variable);

      switch (variable.kind) {
        case SubcomponentVariableKind.asyncSnapshot:
          buffer.writeln(
              '$type $name = const $zapPrefix.ZapSnapshot.unresolved(); // ${variable.element.name}');
          break;
        case SubcomponentVariableKind.forBlockElement:
        case SubcomponentVariableKind.forBlockIndex:
          needsInitialization.add(name);
          buffer.writeln('$type $name; // ${variable.element.name}');
          break;
      }
    }

    final initializers = [_parentField]
        .followedBy(needsInitialization)
        .map((e) => 'this.$e')
        .join(',');

    buffer
      ..writeln('final $parentType $_parentField;')
      ..writeln('$name($initializers);');

    writeNodesAndBlockHelpers();
    writeCreateMethod();
    writeUpdateMethod();
    writeRemoveMethod();
    writePropertyAccessors();

    buffer.writeln('}');
  }
}

/// A writer for Dart types that automatically adds the right imports for all
/// types.
class _DartTypeWriter extends TypeVisitor<void> {
  final Generator generator;
  final StringBuffer buffer;

  _DartTypeWriter(this.generator, this.buffer);

  void _writeSuffix(NullabilitySuffix suffix) {
    switch (suffix) {
      case NullabilitySuffix.question:
        return buffer.write('?');
      case NullabilitySuffix.star:
        return buffer.write('*');
      case NullabilitySuffix.none:
        return;
    }
  }

  void _writeElement(Element element, String name) {
    final library = element.library;
    if (library != null && library != generator.component.resolvedTmpLibrary) {
      final import = generator.imports.importForLibrary(library);
      buffer.write('$import.');
    }

    buffer.write(name);
  }

  @override
  void visitDynamicType(DynamicType type) {
    buffer.write('dynamic');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitFunctionType(FunctionType type) {
    type.returnType.accept(this);

    buffer.write(' Function');
    final formals = type.typeFormals;
    if (formals.isNotEmpty) {
      buffer.write('<');
      var i = 0;
      for (final arg in formals) {
        if (i != 0) {
          buffer.write(', ');
        }

        buffer.write(arg.name);
        final bound = arg.bound;
        if (bound != null) {
          buffer.write(' extends ');
          bound.accept(this);
        }
        i++;
      }
      buffer.write('>');
    }

    // Write parameters
    buffer.write('(');
    var i = 0;

    String? activeOptionalBlock;

    for (final parameter in type.parameters) {
      if (parameter.isNamed) {
        if (activeOptionalBlock == null) {
          buffer.write('{');
          i = 0; // Don't put a comma before the first named parameter
          activeOptionalBlock = '}';
        }
      } else if (parameter.isOptionalPositional) {
        if (activeOptionalBlock == null) {
          buffer.write('[');
          i = 0; // Don't put a comma before the first optional parameter
          activeOptionalBlock = ']';
        }
      }

      if (i != 0) {
        buffer.write(', ');
      }

      parameter.type.accept(this);
      if (parameter.isNamed) {
        buffer.write(' ${parameter.name}');
      }
      i++;
    }

    if (activeOptionalBlock != null) {
      buffer.write(activeOptionalBlock);
    }

    buffer.write(')');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitInterfaceType(InterfaceType type) {
    final alias = type.alias;
    if (alias != null) {
      _writeElement(alias.element, alias.element.name);
    } else {
      _writeElement(type.element, type.element.name);
    }

    if (type.typeArguments.isNotEmpty) {
      buffer.write('<');
      var i = 0;
      for (final arg in type.typeArguments) {
        if (i != 0) {
          buffer.write(', ');
        }

        arg.accept(this);
      }
      buffer.write('>');
    }

    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitNeverType(NeverType type) {
    buffer.write('Never');
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitTypeParameterType(TypeParameterType type) {
    buffer.write(type.element.name);
    _writeSuffix(type.nullabilitySuffix);
  }

  @override
  void visitVoidType(VoidType type) {
    buffer.write('void');
    _writeSuffix(type.nullabilitySuffix);
  }
}

class _DartSourceRewriter extends GeneralizingAstVisitor<void> {
  final Generator generator;
  final ZapVariableScope? scope;
  final ZapVariableScope rootScope;

  final bool patchSelf;

  final int startOffsetInDart;
  int skew = 0;
  String content;

  _DartSourceRewriter(this.generator, this.scope, this.startOffsetInDart,
      this.content, this.patchSelf)
      : rootScope = generator.component.component.scope;

  static String patchDartReferences({
    required AstNode dartCode,
    required Generator generator,
    bool patchSelf = true,
    ComponentOrSubcomponent? component,
  }) {
    final originalCode = generator.prepareResult.temporaryDartFile
        .substring(dartCode.offset, dartCode.offset + dartCode.length);
    final rewriter = _DartSourceRewriter(
        generator, component?.scope, dartCode.offset, originalCode, patchSelf);
    dartCode.accept(rewriter);
    return rewriter.content;
  }

  /// Replaces the range from [start] with length [originalLength] in the
  /// [content] string.
  ///
  /// The [skew] value is set accordingly so that [start] can refer to the
  /// original offset before making any changes. This only works when
  /// [_replaceRange] is called with increasing, non-overlapping offsets.
  void _replaceRange(int start, int originalLength, String newContent) {
    var actualStart = skew + start - startOffsetInDart;

    content = content.replaceRange(
        actualStart, actualStart + originalLength, newContent);
    skew += newContent.length - originalLength;
  }

  void _replaceNode(SyntacticEntity node, String newContent) {
    _replaceRange(node.offset, node.length, newContent);
  }

  BaseZapVariable? _variableFor(Element? element) {
    ZapVariableScope? scope = this.scope;

    while (scope != null) {
      final variable =
          scope.declaredVariables.firstWhereOrNull((v) => v.element == element);
      if (variable != null) {
        return variable;
      }

      scope = scope.parent;
    }

    return null;
  }

  /// Writes Dart code necessary to access variables defined in the
  /// [targetScope].
  ///
  /// When the [targetScope] is the current [scope], the result will be empty.
  /// When its a parent of the current scope, the result would be `parent.`.
  /// For scopes further up, `parent.` would be repeated.
  String _prefixFor(ZapVariableScope targetScope, {bool trailingDot = true}) {
    var current = scope;
    if (current == null) {
      return trailingDot ? 'this.' : '';
    }

    final result = StringBuffer();

    while (current != targetScope) {
      if (result.isNotEmpty) {
        result.write('.');
      }

      result.write(_parentField);
      current = current!.parent!;
    }

    if (trailingDot && result.isNotEmpty) {
      result.write('.');
    }

    return result.toString();
  }

  String invalidateExpression(String bitmaskCode) {
    if (scope == rootScope) {
      return '\$invalidate($bitmaskCode);';
    } else {
      final prefix = _prefixFor(rootScope);
      return '$prefix\$invalidateSubcomponent(this, $bitmaskCode);';
    }
  }

  void _visitCompoundAssignmentExpression(CompoundAssignmentExpression node) {
    final target = node.writeElement;
    final variable = _variableFor(target);
    final notifyUpdate = variable != null && variable.needsUpdateTracking;

    // Wrap the assignment in an $invalidateAssign block so that it can still
    // be used as an expression while also scheduling a node update!
    if (notifyUpdate) {
      final updateCode = variable.updateBitmask;

      if (scope == rootScope) {
        _replaceRange(node.offset, 0, '\$invalidateAssign($updateCode, ');
      } else {
        final prefix = _prefixFor(rootScope);
        _replaceRange(node.offset, 0,
            '$prefix.\$invalidateAssignSubcomponent(this, $updateCode, ');
      }
    }

    node.visitChildren(this);

    if (notifyUpdate) {
      _replaceRange(node.offset + node.length, 0, ')');
    }
  }

  @override
  void visitAssignmentExpression(AssignmentExpression node) {
    _visitCompoundAssignmentExpression(node);
  }

  @override
  void visitPrefixExpression(PrefixExpression node) {
    _visitCompoundAssignmentExpression(node);
  }

  @override
  void visitPrefixedIdentifier(PrefixedIdentifier node) {
    final targetOfPrefix = node.prefix.staticElement;
    if (targetOfPrefix is PrefixElement) {
      // Pointing towards a named import. We're rewriting imports either way, so
      // just write the rest
      _replaceNode(node.prefix, '');
      _replaceNode(node.period, '');
      visitSimpleIdentifier(node.identifier);
    } else {
      super.visitPrefixedIdentifier(node);
    }
  }

  @override
  void visitPostfixExpression(PostfixExpression node) {
    _visitCompoundAssignmentExpression(node);
  }

  @override
  void visitSimpleIdentifier(SimpleIdentifier node) {
    final target = node.staticElement;
    final targetLibrary = target?.library;
    if (targetLibrary != generator.component.resolvedTmpLibrary) {
      // Referencing an element from an import, add necessary import prefix.
      final isTopLevel = targetLibrary != null &&
          targetLibrary.topLevelElements.contains(target);

      if (isTopLevel) {
        final importPrefix = generator.imports.importForLibrary(targetLibrary);
        _replaceRange(node.offset, 0, '$importPrefix.');
      } else if (target is ExecutableElement &&
          !target.isStatic &&
          target.enclosingElement is ExtensionElement) {
        final extension = target.enclosingElement as ExtensionElement;
        final name = extension.name;

        // Target is from an extension, import that extension without an alias
        // so that the extension invocation continues to work.
        if (name != null) {
          generator.imports.importWithoutAlias(extension.library, name);
        }
      }
      return;
    }

    final variable = _variableFor(target);

    if (variable is SelfReference) {
      // Inside the main component, we can replace `self` with `this`. In
      // inner components, we have to walk the parent.

      if (patchSelf) {
        if (rootScope == scope) {
          _replaceNode(node, 'this');
        } else {
          final prefix = _prefixFor(rootScope, trailingDot: false);
          _replaceNode(node, prefix);
        }
      }
    } else if (target is FunctionElement &&
        generator.component.userDefinedFunctions.contains(target)) {
      final newName = generator._nameForFunction(target);
      final prefix = _prefixFor(rootScope);

      _replaceNode(node, '$prefix$newName');
    } else if (variable != null) {
      final prefix = _prefixFor(variable.scope);
      final name = generator._nameForVar(variable);

      final replacement = '$prefix$name /* ${node.name} */';
      _replaceNode(node, replacement);
    }
  }
}
