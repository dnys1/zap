import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:collection/collection.dart';

import 'component.dart';

class ZapVariableScope {
  ComponentOrSubcomponent? owningComponent;

  final List<BaseZapVariable> declaredVariables = [];
  final List<ZapVariableScope> childScopes = [];
  ZapVariableScope? parent;

  final FunctionDeclaration function;
  final Map<TypeParameterElement, DartType> instantiation;

  ZapVariableScope(this.function, {this.instantiation = const {}});

  SubcomponentVariable? findForSubcomponent(SubcomponentVariableKind kind) {
    return declaredVariables
        .whereType<SubcomponentVariable>()
        .firstWhereOrNull((v) => v.kind == kind);
  }
}

/// Base class for variables that can be used in the DOM part of a zap
/// component.
abstract class BaseZapVariable {
  /// The amount of individual bits we can control with JavaScript numbers.
  static const _availableUpdateSlots = 53;

  /// The scope or component where this variable was declared.
  final ZapVariableScope scope;

  /// Whether this variable is mutated somewhere.
  ///
  /// We can generate more efficient code for immutable expressions, so we don't
  /// want to consider a variable mutable just because it doesn't have a
  /// `final` modifier. Instead, we set this field to `true` as soon as we find
  /// a matching assignment.
  bool isMutable = false;

  /// Whether this variable is read in any [ResolvedDartExpression] appearing in
  /// the components DOM tree.
  ///
  /// We need to track updates to variables that are mutable and used in the
  /// DOM.
  bool isInReactiveRead = false;

  /// The synthetic Dart construct backing this variable.
  AstNode get declaration;

  /// The [Element] created by the [declaration].
  PromotableElement get element;

  /// The resolved type of this variable.
  ///
  /// See [ResolvedDartExpression.type] for a discussion on why this might be
  /// different from the declared type of [element].
  DartType get type => element.type;

  int? _updateSlot;

  BaseZapVariable._(this.scope);

  /// An index for this variable when running updates.
  ///
  /// Updates are encoded as a bitmap.
  int? get updateSlot => _updateSlot;

  set updateSlot(int? value) {
    if (value == null) {
      _updateSlot = null;
    } else {
      _updateSlot = value % _availableUpdateSlots;
    }
  }

  int get updateBitmask => 1 << updateSlot!;

  bool get needsUpdateTracking => isMutable && isInReactiveRead;
}

/// A variable declared as a top-level statement in a zap `<script>`.
///
/// The [scope] of such variables is always the top-level scope associated with
/// the root component.
class DartCodeVariable extends BaseZapVariable {
  @override
  final VariableDeclaration declaration;
  @override
  final LocalVariableElement element;

  /// Whether this variable was declared as a `@prop` that can be set by outer
  /// components.
  final bool isProperty;

  DartCodeVariable({
    required ZapVariableScope scope,
    required this.declaration,
    required this.element,
    this.isProperty = false,
  }) : super._(scope) {
    if (isProperty) {
      // Properties are always mutable.
      isMutable = true;
    }
  }
}

/// A variable introduced by a specific component, such as an `async` or `for`
/// block.
///
/// For example:
///
///  - in `{await each snapshot from stream} {/await}`, `snapshot` is a variable
///    bound to the result of the snapshot.
///  - in `{for element in it}`, `element` is a variable bound to the element
///    iterable for which the subcomponent is rendered.
class SubcomponentVariable extends BaseZapVariable {
  @override
  final FormalParameter declaration;
  @override
  final ParameterElement element;
  final SubcomponentVariableKind kind;

  @override
  final DartType type;

  SubcomponentVariable({
    required ZapVariableScope scope,
    required this.declaration,
    required this.type,
    required this.element,
    required this.kind,
  }) : super._(scope);
}

/// The `self` keyword, which refers to the component being rendered.
class SelfReference extends BaseZapVariable {
  @override
  final FormalParameter declaration;
  @override
  final ParameterElement element;

  SelfReference(ZapVariableScope scope, this.declaration, this.element)
      : super._(scope);
}

enum SubcomponentVariableKind {
  asyncSnapshot,
}

class ResolvedDartExpression {
  final Expression expression;

  /// The actual type of the [expression] used here.
  ///
  /// This is not necessarily the same thing as its [Expression.staticType]:
  /// In some cases, the expressions generated by the preparation steps are
  /// not fully resolved. Consider for instance an async block like
  /// `{# await each snapshot from stream} {{ snapshot }} {/await}`. Here,
  /// helper code is generated as:
  ///
  /// ```dart
  /// void __zap__helper<T>(ZapSnapshot<T> var) {
  ///   final __zap__expression_1 = var;
  /// }
  /// ```
  ///
  /// In the resolved model from the analyzer, the expression has a type of
  /// `ZapSnapshot<T>`. This type would get substituted based on the type
  /// analysis of `stream`.
  final DartType type;

  ResolvedDartExpression(this.expression, this.type);
}
